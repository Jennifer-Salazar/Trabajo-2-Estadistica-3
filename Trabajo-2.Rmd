---
title: "Trabajo 2- Estadística 3"
author: "Cristina Mercedes Ortega Benavides"
date: "18/5/2021"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Introducción

* Definición DANE del índice asignado (ecuación debidamente explicada) dando ejemplo interpretativo de sus valores

* Definición del dominio o clasificación industrial al que está relacionada la serie. 

* Resultados alcanzados en el trabajo 1

- Cuáles modelos globales y locales que fueron propuestos (debe dar las ecuaciones teóricas)

- Cuál es el mejor modelo global, qué logró explicar este modelo en relación a los patrones que fueron observados sobre la serie

- Resultó mejor el ajuste y pronóstico global vs. lo local (cuál fue el mejor local entre Holt-Winters y combinación del filtro de la descomposición con loess) y por qué.

# 2. Análisis descriptivo de la serie, modelo global asignado y sus resultados:

a) Presente y analice brevemente la gráfica de la serie (y su logaritmo natural si la serie es multiplicativa)
indicando los patrones observables de tendencia, estacionalidad, varianza, ciclos. Grafique y analice además
la ACF de la serie (para el caso multiplicativo sólo presente y analice la ACF del logaritmo natural) y concluya en términos de estacionariedad o no y por qué, contrastando con lo que a partir de la gráfica de la serie se concluye al respecto.

```{r}
Datos20=read.table("anex-EMMET-dic2019-Fabricacion de otros productos quimicos (1).csv",header=T,sep=";",skip=14,dec=",",colClasses=c(rep("NULL",4),"numeric",rep("NULL",6)))

Datos20=ts(Datos20,freq=12,start=c(2001,1))
```

# #d8576b

```{r, fig.height=5, fig.width=6}
plot(Datos20, lwd=2, xlab="Tiempo", ylab = "Producción nominal", col = '#717D7E')
grid()
title(sub= '(a)')
# title(main = "Índice de producción nominal \n del sector manufacturero (Colombia) \n", 
#       sub = 'Clase industria: Otros productos químicos')
```
```{r}
# Dispositivo JPEG
jpeg(filename="Grafico3.jpeg",   # Nombre del archivo y extension
     width = 20,    # Anchura
     height = 20,   # Altura
     res= 100,       # Resolucion 72ppi es un estandar
     units = "cm")  # Unidades.

plot(Datos20, lwd=2, xlab="Tiempo", ylab = "Producción nominal", col = "#d8576b")
grid()
title(sub= '(a)')

# Cerramos el dispositivo 
dev.off()

```


```{r}
require(forecast)
```


```{r, fig.height=5, fig.width=6}
par(bg='gray98')
acf(Datos20,lag.max=36,ci.type="ma",col="cyan4", ci.col=2, lwd=2, main = 'Procucción nominal')
grid()
```


b) Para el modelo de regresión global señalado en la Tabla 1

* la ecuación teórica con sus supuestos 

$$\text{Modelo cuadrático estacional con indicadoras, mes de referencia diciembre}\\
Y_t=\beta_0+\beta_1t+\beta_2t^2+\sum_{i=1}^{11}\delta_iI_{i,t}+E_t, ~~~ \{E_t\}_{t\in Z^+} \text{un RB} \sim N(0, \sigma^2)$$



* con la estrategia de validación cruzada usando la misma longitud n = 216 de ajuste del trabajo anterior ajuste nuevamente este modelo y reporte los resultados de ajuste

```{r}
m <- 12 # numero de periodos a pronosticar dentro de la muestra
n <-length(Datos20)-m # tamaño de la muestra para el ajuste
t <- 1:n #Indice de tiempo en los periodos de ajuste
t2 <- t^2

# Datos para el ajuste:

yt <- ts(Datos20[t], frequency = 12, start=c(2001, 1))

# Creación de las variables indicadoras para los datos de muestra

mes <- seasonaldummy(yt) #Matriz con las 11 primeras variables Indicadoras mes

#Separando una a una las 11 variables indicadoras

I1 <- mes[,1]
I2 <- mes[,2]
I3 <- mes[,3]
I4 <- mes[,4]
I5 <- mes[,5]
I6 <- mes[,6]
I7 <- mes[,7]
I8 <- mes[,8]
I9 <- mes[,9]
I10 <- mes[,10]
I11 <- mes[,11]

# Creación de las variables indicadoras para los datos de validación cruzada

tnuevo <- (n+1):length(Datos20)
ytnuevo <- ts(Datos20[tnuevo], frequency = 12, start = c(2019, 1))

mesnuevo <- seasonaldummy(yt, h=12)
#Separando una a una las 11 indicadoras para los tiempos de pron?stico
I1n=mesnuevo[,1]
I2n=mesnuevo[,2]
I3n=mesnuevo[,3]
I4n=mesnuevo[,4]
I5n=mesnuevo[,5]
I6n=mesnuevo[,6]
I7n=mesnuevo[,7]
I8n=mesnuevo[,8]
I9n=mesnuevo[,9]
I10n=mesnuevo[,10]
I11n=mesnuevo[,11]

## Ajuste del Modelo cuadrático estacional con indicadoras

mod1 <- lm(yt~t+I(t^2)+I1+I2+I3+I4+I5+I6+I7+I8+I9+I10+I11)
```


- tabla de parámetros estimados

$$\begin{array}{| c | c | c | c| c |}
\hline
Parametro&Estimación&Error~Estándar&T_0&P(|T_{202}|>|T_0|)\\
\hline
\beta_0&35.8242551&1.2250562&29.242949&0.0000000\\
\beta_1&0.1319807&0.0174478&7.564309&0.0000000\\
\beta_2&0.0007051&0.0000779&9.055350&0.0000000\\
\delta_1&-3.1817818&1.3273503&-2.397093&0.0174368\\
\delta_2&5.3069465&1.3272009&3.998601&0.0000893\\
\delta_3&12.0220423&1.3270660&9.059114&0.0000000\\
\delta_4&7.2690612&1.3269454&5.478041&0.0000001\\
\delta_5&12.1146698&1.3268389&9.130475&0.0000000\\
\delta_6&9.8255350&1.3267465&7.405736&0.0000000\\
\delta_7&8.4294343&1.3266681&6.353838&0.0000000\\
\delta_8&9.0930346&1.3266037&6.854372&0.0000000\\
\delta_9&12.5163357&1.3265533&9.435230&0.0000000\\
\delta_{10}&10.5493377&1.3265171&7.952659&0.0000000\\
\delta_{11}&8.9475962&1.3264952&6.745291&0.0000000\\
\hline
\end{array}$$

```{r}
summary(mod1)
```


```{r}
require(kableExtra)

require(broom)

# tidy(summary(mod1)) %>% 
#   kbl() %>% 
#   kable_classic()

```


- medidas de ajuste

```{r}
# Calculo del AIC y BIC

#Creando funci?n usuario crit.inf.resid() para calcular C^*_n(p)
crit.inf.resid <- function(residuales,n.par,AIC="TRUE"){
if(AIC=="TRUE"){
#Calcula AIC
CI=log(mean(residuales^2))+2*n.par/length(residuales)
}
if(AIC=="FALSE"){
#Calcula BIC
CI=log(mean(residuales^2))+n.par*log(length(residuales))/length(residuales)
}
CI
}  
```

modelo 1
```{r}
resmod1.orig <- residuals(mod1) #seudo-residuos en la escala original. Usados solo para calcular AIC y BIC

npar1 <- length(coef(mod1)[coef(mod1)!=0]) #numero parametros modelo 1

AIC1 <- exp(crit.inf.resid(resmod1.orig,n.par=npar1))
BIC1 <- exp(crit.inf.resid(resmod1.orig ,n.par=npar1, AIC="FALSE"))
```

$$\begin{array}{| c | c | c |}
\hline
p&AIC&BIC\\
\hline
14&16.85948&20.98234\\
\hline
\end{array}$$

- gráfico del ajuste

# Valores ajustados de los modelos 

```{r}
mod1_ajust <- ts(fitted(mod1), start  = c(2001,1), frequency = 12)
```


```{r, fig.height=5, fig.width=6}
plot(Datos20, ylab = 'Producción nominal', xlab = 'Tiempo', col = '#717D7E', lwd = 2)
lines(mod1_ajust, col='#3498DB', lwd=2)
legend("topleft", legend = c("Original", "Ajuste"), lty=1, col=c('#717D7E', '#3498DB'))
grid()
```



* pronósticos

- Ecuación de pronóstico

$$
\hat{Y}_{216}(L) \approx 35.8242551 + 0.1319807 (216+L) + 0.0007051 (216+L)^2	\\ 
- 3.1817818 I_{1,216+L} + 5.3069465 I_{2,216+L} + 12.0220423 I_{3,216+L} + 7.2690612 I_{4,216+L} + 12.1146698 I_{5,216+L} \\ + 9.8255350 I_{6,216+L} + 8.4294343 I_{7,216+L} + 9.0930346 I_{8,216+L}+ 12.5163357 I_{9,216+L}+ 10.5493377 I_{10,216+L}+ 8.9475962 I_{11,216+L}
$$
```{r}
ytpron1 <- predict(mod1, newdata=data.frame(t=tnuevo, I1=I1n, I2=I2n, I3=I3n, I4=I4n, I5=I5n, I6=I6n, I7=I7n, I8=I8n, I9=I9n, I10=I10n, I11=I11n), interval="prediction")
ytpron1 <- ts(ytpron1,freq=12,start=c(2019,1))
ytpron1
```



- la tabla de pronósticos

$$\begin{array}{| c | c | c | c| c |}
\hline
Periodo&L&Pronósticos&Lim.Inf&Lim.Sup\\
\hline
Ene~2019&1&94.4852&86.27520&102.6952\\
Feb~2019&2&103.4126&95.19741&111.6279\\
Mar~2019&3&110.5678&102.34725&118.7884\\
Abr~2019&4&106.2564&98.03028&114.4825\\
May~2019&5&111.5449&103.31316&119.7767\\
Jun~2019&6&109.7001&101.46257&117.9377\\
Jul~2019&7&108.7498&100.50627&116.9933\\
Ago~2019&8&109.8606&101.61094&118.1102\\
Sep~2019&9&113.7324&105.47658&121.9883\\
Oct~2019&10&112.2154&103.95319&120.4777\\
Nov~2019&11&111.0651&102.79632&119.3338\\
Dic~2019&12&102.5703&94.29486&110.8457\\
\hline
\end{array}$$

- medidas de cobertura amplitud media de los I.P y medidas MAE, MAPE y RMSE 

$$\begin{array}{| c | c | c | c| c |}
\hline
RMSE & MAE & MAPE & Amplitud & Cobertura\\
\hline
3.153708&2.366654&2.338060&16.48278&100\\
\hline
\end{array}$$

* Conclusión breve sobre la calidad del ajuste y de los pronósticos con este modelo


* Gráfica de pronóstico

```{r, fig.height=5, fig.width=6}
plot(ytnuevo,lwd=2, col="#717D7E", type="b", pch=1, xlab="Periodo del año", ylab="")
lines(ytpron1[,1],lwd=2, col="purple", type="b", pch=2)
grid()
legend("bottomright",legend=c("Real","Pronóstico del modelo global"),col=c("#717D7E","purple"),lwd=2, pch=1:2, cex=0.8)

```


# 3. Evaluación de supuesto de ruido blanco e identificación de procesos estocásticos sobre los errores estructurales del modelo global

a) Validación de supuestos: Guarde los residuos estructurales $\hat{E}_t$ en la escala en que ajustó la serie. Analice inicialmente las gráficas de estos residuales en términos de los supuestos sobre los errores Et de media constante en cero, varianza constante y determine si hay ciclos evidentes no explicados o rachas en signos ±, qué concluye frente a la existencia de estos patrones. 

```{r}
residuales <- residuals(mod1)
```

```{r, fig.height=5, fig.width=6}
plot(residuales, type = "l", xlab = 'Tiempo', ylab = 'Residuales', col = '#01588A', lwd = 1)
abline(h=c(-2*summary(mod1)$sigma, 0, 2*summary(mod1)$sigma), col=2)
abline(h = 0, col=2)
grid()
```

Realice las Pruebas de incorrelación con: 

- Ljung-Box 

> Prueba de hipótesis

$$H_0 : \rho(1) = \rho(2) = \rho(3) = \ldots = \rho(m) = 0 $$
$$H_1: \rho(k) \neq 0, \text{ para al menos un } k= 1, 2, … , m$$

> Estadístico de prueba

$$Q_{LB} = 216 (216+2) \sum_{k=L}^m \frac{\widehat{\rho^2}(k)}{216-k} \sim \text{aprox } \chi^2_m$$


```{r}
#DEFINIENDO FUNCION USUARIO PARA TESTES BOX-PIERCE Y LJUNG-BOX
BP.LB.test=function(serie,maxlag,type="Box"){
aux=floor(maxlag/6); X.squared=c(rep(NA,aux))
df=c(rep(NA,aux)); p.value=c(rep(NA,aux))
for(i in 1:aux){
test=Box.test(serie,lag=(6*i),type=type)
X.squared[i]=test[[1]]; df[i]=test[[2]]
p.value[i]=test[[3]]
}
lag=6*c(1:aux)
teste=as.data.frame(cbind(X.squared,df,p.value))
rownames(teste)=lag; teste
}

LB_result <- BP.LB.test(residuals(mod1),maxlag=36,type="Ljung")


# cbind("m" = seq(6, 36, 6), LB_result)  %>% 
#   kbl(col.names = c('$m$', '$Q_{LB}$', '$gl$', '$p(χ^2_{m} > Q_{LB})$'), row.names = F) %>% 
#   kable_classic(full_width = F) 

```

```{r}
xtable::xtable(LB_result)
```

$$\begin{array}{cccc}
  \hline
m & Q_{LB} & gl & p(\chi^2_{m} > Q_{LB}) \\ 
  \hline
6 & 161.91 & 6.00 & 0.00 \\ 
  12 & 196.24 & 12.00 & 0.00 \\ 
  18 & 216.31 & 18.00 & 0.00 \\ 
  24 & 259.14 & 24.00 & 0.00 \\ 
  30 & 315.97 & 30.00 & 0.00 \\ 
  36 & 385.48 & 36.00 & 0.00 \\ 
   \hline
\end{array}$$

- Durbin-Watson

```{r}
require(car)
#DEFINIENDO FUNCION USUARIO PARA TEST DURBIN-WATSON
pruebaDW1=function(modelo){
dwneg=durbinWatsonTest(modelo,max.lag=1,method="normal",alternative="negative")
dwpos=durbinWatsonTest(modelo,max.lag=1,method="normal",alternative="positive")

res=data.frame(1,dwneg$r,dwneg$dw,dwpos$p,dwneg$p)
names(res)=c("lag","rho estimado","Estadístico D-W",
"VP rho>0","VP rho<0")
res
}

# pruebaDW1(mod1) 


# xtable::xtable(pruebaDW1(mod1))

```



$$
\begin{array}{cccccc}
  \hline
 & k & \widehat{\rho}(1) & \text{Estadístico } d_1 & P(DW_1 < d1) & P(DW_1 > d1) \\ 
  \hline
 & 1 & 0.41 & 1.17 & 0.00 & 1.00 \\ 
   \hline
\end{array}
$$

> Modelo Durbin Watson

$$\text{Modelo Durbin Watson}\\
Y_t=  \sum_{j=1}^2 \beta_jt^j+\sum_{i=1}^{11}\delta_iI_{i,t}+E_t, \text{ con } E_t = \phi_1E_{t-1} + a_t$$

$$|\phi_1|<1  \text{ y }  \{a_t\}_{t\in Z^+} \text{un RB} \sim N(0, \sigma_a^2)$$
* Como $d_1 < 2$, por lo tanto el test a realizar es:

$$H_0: \rho(1) = corr(E_t, E_{t+1}) = \phi_1 = 0 \text{ vs } H_1: \rho(1) = corr(E_t, E_{t+1}) > 0$$
* El valor p es: $P(DW_1 < d1) \approx 0$, conduce al rechazo de $H_0$ en favor de $H_1$, por tanto en los dos modelos $\{E_t\}_{t \in Z^+}$ no es R.B pues presenta autocorrelación de orden 1 positiva.




- gráficas de la ACF y PACF con bandas de Bartlett.

```{r, fig.height=5, fig.width=6}
acf(residuales,lag.max=36,ci.type="ma",col="cyan4",ci.col=2, lwd=2, main = 'ACF de los residuales')
```

```{r, fig.height=5, fig.width=6}
pacf(residuales,lag.max=36,col="cyan4",ci.col=2, lwd=2, main = 'PACF de los residuales')
```

Concluya sobre si los errores estructurales Et son ruido blanco o no y en este último caso, evalúe si por lo menos son estacionarios con media cero.



#######################################################################################

Jennifer....

Identificando modelos ARMA

```{r}
library(forecast)
library(FitAR)
library(TSA)
```



Análisis de ACF  

```{r, fig.height=5, fig.width=6}
acf(residuales,lag.max=36,ci.type="ma",col="cyan4",ci.col=2, lwd=2, main = 'ACF de los residuales')
```

Opiniones:

Juan Esteban: tiene patrón tipo corte, con corte en q = 6
Cristina: tiene patrón tipo cola
Jennifer: tiene patrón tipo corte, con corte en q=6 o 9
Miguel: tiene patrón tipo cola

Análisis de PACF

```{r, fig.height=5, fig.width=6}
pacf(residuales,lag.max=36,col="cyan4",ci.col=2, lwd=2, main = 'PACF de los residuales')
```

Juan Esteban: Patrón tipo cola 
Cristina: Patrón tipo cola
Jennifer: Patrón tipo cola (Exponencial sinusoidal)
Miguel: Patrón tipo corte


Análisis de EACF

```{r}
eacf(residuales,ar.max=36,ma.max=36)
```

Juan Esteban: ARMA(4,7)
Cristina: ARMA(4,7)
Jennifer: ARMA(4,7)
Miguel: ARMA(4,7)

(Colocar el modelo de un ARMA (4,7))

Análisis con SelectModel()

```{r}
library(FitAR)
SelectModel(residuales, lag.max = 36,  Criterion="AIC")
SelectModel(residuales, lag.max = 36,  Criterion="BIC")
```

Se identifican los siguientes modelos para $E_t$:

Por AIC: 

El mejor modelo es un AR(16): 

$$E_t = \sum_{j=1}^{16} \phi_i E_{t-j} + a_t,  ~ con~ \{a_t\}_{t \in Z^+} ~ un ~ R.B \sim N(0, \sigma^2_a) $$

El segundo mejor modelo es un AR(18):

$$E_t = \sum_{j=1}^{18} \phi_i E_{t-j} + a_t,  ~ con~ \{a_t\}_{t \in Z^+} ~ un ~ R.B \sim N(0, \sigma^2_a)$$

y el tercer mejor modelo es un AR(17):

$$E_t = \sum_{j=1}^{17} \phi_i E_{t-j} + a_t,  ~ con~ \{a_t\}_{t \in Z^+} ~ un ~ R.B \sim N(0, \sigma^2_a)$$


Por BIC: 

El mejor modelo es un AR(3): 

$$E_t = \sum_{j=1}^{3} \phi_i E_{t-j} + a_t,  ~ con~ \{a_t\}_{t \in Z^+} ~ un ~ R.B \sim N(0, \sigma^2_a)$$

El segundo mejor modelo es un AR(4):

$$E_t = \sum_{j=1}^{4} \phi_i E_{t-j} + a_t,  ~ con~ \{a_t\}_{t \in Z^+} ~ un ~ R.B \sim N(0, \sigma^2_a)$$

y el tercer mejor modelo es un AR(2):

$$E_t = \sum_{j=1}^{2} \phi_i E_{t-j} + a_t,  ~ con~ \{a_t\}_{t \in Z^+} ~ un ~ R.B \sim N(0, \sigma^2_a)$$



Análisis con auto.arima()


```{r}
library(forecast)

SerieEt <- ts(residuales,freq=12,start=c(2001,1))

auto.arima(residuales, ic="aic")
auto.arima(residuales, ic="bic")
auto.arima(SerieEt, ic="aic")
auto.arima(SerieEt, ic="bic")
```

Se identifica el mismo modelo en todos los casos, según los criterios AIC y BIC y con el vector de residuales sin fechas y con fechas:

$E_t$ es un ARIMA(1,0,2)=ARMA(1,2) estacionario y de media cero, entonces:


$$E_t=\phi_1E_{t-1}+a_t+\theta_1 a_{t-1}+\theta_2 a_{t-2} ~~ con \{a_t\}_{t \in Z^+} un ~R.B \sim N(0, \sigma^2_a) $$

Análisis con armasubsets()


```{r}
library(TSA)
armasubsets(residuales, nar = 24, nma =24,  ar.method="ml")
```


```{r}
plot(armasubsets(residuals(mod1),nar=24,nma=24,y.name='AR',ar.method='ml'))
```


Renglón 1: 

$$E_t= \phi_1E_{t-1}+\phi_2E_{t-2}+\phi_3E_{t-3}+\phi_{11}E_{t-11}+\phi_{16}E_{t-16}+a_t+\theta_{16}a_{t-16}+\theta_{17}a_{t-17}$$

$$con~ \{a_t\}_{t \in Z^+} ~ un ~ R.B \sim N(0, \sigma^2_a)$$

$$es ~ decir~, ~E_t~ es~ un ~ARMA(16,17)~ pero~sólo~ , \phi_{1}, \phi_{2}, \phi_{3}, \phi_{11}, \phi_{16}, \theta_{16} ~y~ \theta_{17} ~van ~en ~el ~modelo.$$




## Sobre ajustes, validación supuestos y pronósticos en R de modelos de regresión con errores ARMA

Funciones de usuario:

```{r}
library(forecast);library(lmtest)
#Creando función usuario crit.inf.resid() para calcular C*n(p)
crit.inf.resid=function(residuales,n.par,AIC="TRUE"){
if(AIC=="TRUE"){
#Calcula AIC
CI=log(mean(residuales^2))+2*n.par/length(residuales)
}
if(AIC=="FALSE"){
#Calcula BIC
CI=log(mean(residuales^2))+n.par*log(length(residuales))/length(residuales)
}
CI
}
#DEFINIENDO FUNCIÓN USUARIO PARA TEST LJUNG-BOX
BP.LB.test=function(serie,maxlag,type="Box"){
aux=floor(maxlag/6); X.squared=c(rep(NA,aux))
df=c(rep(NA,aux)); p.value=c(rep(NA,aux))
for(i in 1:aux){
test=Box.test(serie,lag=(6*i),type=type)
X.squared[i]=test[[1]]; df[i]=test[[2]]
p.value[i]=test[[3]]
}
lag=6*c(1:aux)
teste=as.data.frame(cbind(X.squared,df,p.value))
rownames(teste)=lag; teste
}
#Función para calcular la amplitud de los I.P
amplitud=function(LIP,LSP){
a=LSP-LIP
am=mean(a)
am
}
#Función para calcular la cobertura de los I.P
cobertura=function(real,LIP,LSP){
I=ifelse(real>=LIP & real<=LSP,1,0)
p=mean(I)
p
}
```


# Modelos lineales en los parámetros de tendencia y estacionalidad, y errores ARMA(p,q) con todos los parámetros.

## Modelo 1


$$ Y_t=\beta_0+\beta_1t+\beta_2t^2+\sum_{i=1}^{11}\delta_iI_{i,t}+E_t, ~~ donde ~~ E_t = \sum_{j=1}^{16} \phi_j E_{t-j} + a_t, ~~con~  \{a_t\}_{t\in Z^+} \text{un RB} \sim N(0, \sigma_a^2) $$

## Modelo 2

$$ Y_t=\beta_0+\beta_1t+\beta_2t^2+\sum_{i=1}^{11}\delta_iI_{i,t}+E_t, ~~ donde ~~ E_t = \sum_{j=1}^{4} \phi_j E_{t-j} + a_t + \sum_{i=1}^{7} \theta_i a_{t-i}, ~~con~  \{a_t\}_{t\in Z^+} \text{un RB} \sim N(0, \sigma_a^2) $$




* Paso 1) 

Lea datos y defina variables necesarias para el ajuste y el pronóstico (en este ejemplo se asumen 12 pronósticos ex – post):

Este paso ya se hizo arriba también

```{r}
# Lectura de los datos
datos=read.table("anex-EMMET-dic2019-Fabricacion de otros productos quimicos (1).csv",header=T,sep=";",skip=14,dec=",",colClasses=c(rep("NULL",4),"numeric",rep("NULL",6)))


datos=ts(datos,freq=12,start=c(2001,1))

n=length(datos)-12 

t=1:n
t2=t^2

yt=ts(datos[t],freq=12,start=c(2001,1)) #serie recortada


#Defina la matriz de variables indicadoras
Indicadoras=seasonaldummy(yt)

X=cbind(t,t2,Indicadoras)

#Definiendo variables para pronósticos
tnuevo=(n+1):length(datos)
t2nuevo=tnuevo^2
Indicadorasnuevo=seasonaldummy(yt,h=12) 

Xnuevo=cbind(t=tnuevo,t2=t2nuevo,Indicadoras=Indicadorasnuevo) #matriz predictores en el pronóstico
ytf=ts(datos[tnuevo],freq=12,start=c(2001,1)) 
```



* Paso 2) 

Ajuste el modelo con función Arima de librería forecast


```{r}
#indique el valor correspondiente a p y q en la función Arima, así como la matriz de predictores X en xreg=X

modelo1<- Arima(yt,order=c(16,0,0),xreg=X,method="ML")
modelo2 <- Arima(yt,order=c(4,0,7),xreg=X,method="ML")  
```


* Paso 3) 

Construya tabla completa de parámetros estimados, valores P corresponden a $𝑃(|𝑡_{n-k}| > |𝑇_0|)$, con $𝑘$ la suma del número de parámetros en las estructuras de tendencia, estacionalidad y errores ARMA.


Asociado al modelo1

```{r}
k1=length(coef(modelo1)[coef(modelo1)!=0])
k1 #número de parámetros del modelo
dfmodelo1=n-k1 # grados de libertad del MSE del modelo
#Construya tabla de parámetros estimados con estadísticos T0 y valores P para cada parámetro
coeftest(modelo1,df=dfmodelo1)
```



Asociado al modelo2

```{r}
k2=length(coef(modelo2)[coef(modelo2)!=0])
k2 #número de parámetros del modelo
dfmodelo2=n-k2 # grados de libertad del MSE del modelo
#Construya tabla de parámetros estimados con estadísticos T0 y valores P para cada parámetro
coeftest(modelo2,df=dfmodelo2)
```


* Paso 4) 

Obtenga gráfica del ajuste de la serie y de los residuales de ajuste $a_t$

Para el modelo 1 
```{r}
#Gráfico de la serie y su ajuste
ythat1=modelo1$fitted #Este objeto ya tiene fechas
plot(datos)
lines(ythat1,col=2)
legend("topleft",legend=c("datos","ajuste modelo1"),lty=1,col=1:2)

#Gráficos de residuales
plot(residuals(modelo1))
abline(h=0)
abline(h=c(-2*sqrt(modelo1$sigma2),2*sqrt(modelo1$sigma2)),lty=2)
plot(as.numeric(modelo1$fitted),residuals(modelo1))
abline(h=0)
abline(h=c(-2*sqrt(modelo1$sigma2),2*sqrt(modelo1$sigma2)),lty=2)
```



Para el modelo 2

```{r}
#Gráfico de la serie y su ajuste
ythat2=modelo2$fitted #Este objeto ya tiene fechas
plot(datos)
lines(ythat2,col=2)
legend("topleft",legend=c("datos","ajuste modelo2"),lty=1,col=1:2)

#Gráficos de residuales
plot(residuals(modelo2))
abline(h=0)
abline(h=c(-2*sqrt(modelo2$sigma2),2*sqrt(modelo2$sigma2)),lty=2)
plot(as.numeric(modelo2$fitted),residuals(modelo2))
abline(h=0)
abline(h=c(-2*sqrt(modelo2$sigma2),2*sqrt(modelo2$sigma2)),lty=2)
```


* Paso 5) 

Cálculo de AIC y BIC, versión $exp(𝐶_n^∗ (𝑝))$ , con el número de parámetros $𝑘$ siendo la suma del número de parámetros en las estructuras de tendencia, estacionalidad y errores ARMA, previamente calculado en 3).

Para el modelo 1

```{r}
AICmodelo1=exp(crit.inf.resid(residuales=residuals(modelo1),n.par=k1))
BICmodelo1=exp(crit.inf.resid(residuales=residuals(modelo1),n.par=k1,AIC="FALSE"))

AICmodelo1
BICmodelo1
```


Para el modelo 2

```{r}
AICmodelo2=exp(crit.inf.resid(residuales=residuals(modelo2),n.par=k2))
BICmodelo2=exp(crit.inf.resid(residuales=residuals(modelo2),n.par=k2,AIC="FALSE"))

AICmodelo2
BICmodelo2
```

* Punto 6)

Valide supuestos sobre el error de ajuste $a_t$

para el modelo 1 

```{r}
#ACF sobre residuales de ajuste en el modelo. Use valor para m el que se indica en la guía del trabajo

acf(as.numeric(residuals(modelo1)),ci.type="ma",lag.max=36,main="ACF modelo1",ci.col=2)

#PACF sobre residuales de ajuste en el modelo. Use valor para m el que se indica en la guía del trabajo

pacf(as.numeric(residuals(modelo1)),lag.max=36,main="PACF modelo1",ci.col=2)

BP.LB.test(residuals(modelo1),maxlag=36,type="Ljung") #test Ljung-Box use máximo m igual al de ACF y PACF

#Normalidad sobre residuales de ajuste en el modelo. Sólo si no se rechaza supuesto de ruido blanco
shapiro.test(residuals(modelo1))
qqnorm(residuals(modelo1),main="Gráfico de normalidad residuos de ajuste modelo1")
qqline(residuals(modelo1),col=2)
```



para el modelo 2 

```{r}
#ACF sobre residuales de ajuste en el modelo. Use valor para m el que se indica en la guía del trabajo
acf(as.numeric(residuals(modelo2)),ci.type="ma",lag.max=36,main="ACF modelo2",ci.col=2)

#PACF sobre residuales de ajuste en el modelo. Use valor para m el que se indica en la guía del trabajo
pacf(as.numeric(residuals(modelo2)),lag.max=36,main="PACF modelo2",ci.col=2)


BP.LB.test(residuals(modelo2),maxlag=36,type="Ljung") #test Ljung-Box use máximo m igual al de ACF y PACF

#Normalidad sobre residuales de ajuste en el modelo. Sólo si no se rechaza supuesto de ruido blanco
shapiro.test(residuals(modelo2))
qqnorm(residuals(modelo2),main="Gráfico de normalidad residuos de ajuste modelo2")
qqline(residuals(modelo2),col=2)
```



* Paso 7) 

Pronósticos para la validación cruzada (en este ejemplo se asume 12 pronósticos ex – post)


Para el modelo 1 

```{r}
predmodelo1=ts(as.data.frame(forecast(modelo1,xreg=Xnuevo,level=95)),freq=12, start=c(2001,1))
predmodelo1
ytpronmodelo1=predmodelo1[,1] #Tomando el pronóstico puntual. Este objeto tiene fechas

#Medidas precisión pronósticos
accuracy(ytpronmodelo1,ytf)
amplitud(LIP=predmodelo1[,2],LSP=predmodelo1[,3])
cobertura(real=ytf,LIP=predmodelo1[,2],LSP=predmodelo1[,3])
```

Para el modelo 2 

```{r}
predmodelo2=ts(as.data.frame(forecast(modelo2,xreg=Xnuevo,level=95)),freq=12, start=c(2001,1))
predmodelo2
ytpronmodelo2=predmodelo2[,1] #Tomando el pronóstico puntual. Este objeto tiene fechas

#Medidas precisión pronósticos
accuracy(ytpronmodelo2,ytf)
amplitud(LIP=predmodelo2[,2],LSP=predmodelo2[,3])
cobertura(real=ytf,LIP=predmodelo2[,2],LSP=predmodelo2[,3])
```


# Modelos lineales en los parámetros de tendencia y estacionalidad, y errores ARMA(p,q) con sólo alguno de los parámetros de esta estructura ARMA.

## Modelo 3

$$ Y_t=\beta_0+\beta_1t+\beta_2t^2+\sum_{i=1}^{11}\delta_iI_{i,t}+E_t, ~~ donde ~~ E_t= \phi_1E_{t-1}+\phi_2E_{t-2}+\phi_3E_{t-3}+\phi_{11}E_{t-11}+\phi_{16}E_{t-16}+a_t+\theta_{16}a_{t-16}+\theta_{17}a_{t-17}, ~~con~  \{a_t\}_{t\in Z^+} \text{un RB} \sim N(0, \sigma_a^2) $$

El paso 1) no hay necesidad de repetirlo 


Paso 2)

Ajuste el modelo con función Arima de librería forecast, además de hacer uso del argumento fixed indicando que parametros entran y cuales no 

```{r}
#indique el valor correspondiente a p y q en la función Arima, así como la matriz de predictores X en xreg=X y
#el vector para argumento fixed
modelo3 <- Arima(yt,order=c(16,0,17),xreg=X, fixed=c(rep(NA,3), rep(0,7), NA, rep(0,4), NA, rep(0,15), NA, NA,rep(NA,14)),  method="ML")
```



Paso 3)

Construya tabla completa de parámetros estimados, valores P


```{r}
#Calcule grados de libertad del MSE del modelo
k3=length(coef(modelo3)[coef(modelo3)!=0])
k3 #número de parámetros del modelo
dfmodelo3=n-k3
#Construya tabla de parámetros estimados con estadísticos T0 y valores P para cada parámetro
coeftest(modelo3,df=dfmodelo3)
```



* Paso 4) 

Obtenga gráfica del ajuste de la serie en escala original y de los residuales de ajuste $\hat{a}_t$



Para el modelo 3

```{r}
#Gráfico de la serie y su ajuste
ythat3=modelo3$fitted #Este objeto ya tiene fechas
plot(datos)
lines(ythat3,col=2)
legend("topleft",legend=c("datos","ajuste modelo3"),lty=1,col=1:2)

#Gráficos de residuales
plot(residuals(modelo3))
abline(h=0)
abline(h=c(-2*sqrt(modelo3$sigma2),2*sqrt(modelo3$sigma2)),lty=2)
plot(as.numeric(modelo3$fitted),residuals(modelo3))
abline(h=0)
abline(h=c(-2*sqrt(modelo3$sigma2),2*sqrt(modelo3$sigma2)),lty=2)
```


* Paso 5)

Calculo del AIC y BIC 


```{r}
AICmodelo3=exp(crit.inf.resid(residuales=residuals(modelo3),n.par=k3))
BICmodelo3=exp(crit.inf.resid(residuales=residuals(modelo3),n.par=k3,AIC="FALSE"))

AICmodelo3
BICmodelo3
```


* Paso 6) 

Valide supuestos sobre el error de ajuste $𝑎_t$


```{r}
#ACF sobre residuales de ajuste en el modelo. Use valor para m el que se indica en la guía del trabajo
acf(as.numeric(residuals(modelo3)),ci.type="ma",lag.max=36,main="ACF modelo3",ci.col=2)

#PACF sobre residuales de ajuste en el modelo. Use valor para m el que se indica en la guía del trabajo
pacf(as.numeric(residuals(modelo3)),lag.max=36,main="PACF modelo3",ci.col=2)

BP.LB.test(residuals(modelo3),maxlag=36,type="Ljung") #test Ljung-Box use máximo m igual al de ACF y PACF

#Normalidad sobre residuales de ajuste en el modelo. Sólo si no se rechaza supuesto de ruido blanco
shapiro.test(residuals(modelo3))
qqnorm(residuals(modelo3),main="Gráfico de normalidad residuos de ajuste modelo3")
qqline(residuals(modelo3),col=2)
```



* Paso 7) 

Pronósticos para la validación cruzada (en este ejemplo se asume 12 pronósticos ex – post)


Para el modelo 3 

```{r}
predmodelo3=ts(as.data.frame(forecast(modelo3,xreg=Xnuevo,level=95)),freq=12, start=c(2001,1))
predmodelo3
ytpronmodelo3=predmodelo3[,1] #Tomando el pronóstico puntual. Este objeto tiene fechas

#Medidas precisión pronósticos
accuracy(ytpronmodelo3,ytf)
amplitud(LIP=predmodelo3[,2],LSP=predmodelo3[,3])
cobertura(real=ytf,LIP=predmodelo3[,2],LSP=predmodelo3[,3])
```



# Modelos lineales en los parámetros de tendencia y estacionalidad, y errores ARMA(p,q)(P,Q)[s]

## Modelo 4 


$$ Y_t=\beta_0+\beta_1t+\beta_2t^2+\sum_{i=1}^{11}\delta_iI_{i,t}+E_t, ~~ donde ~ E_t ~ es~ un~ ARMA(3,6)(1,1)[12], ~es ~decir~ \phi_p(B) \Phi_P (B^{12}) E_t = \theta_q(B) \Theta_Q (B^{12}) a_t, ~~con~  \{a_t\}_{t\in Z^+} \text{un RB} \sim N(0, \sigma_a^2) ~y~ p = 3,~ q = 6,~P = 1,~ Q=1.$$

$$ Y_t=\beta_0+\beta_1t+\beta_2t^2+\sum_{i=1}^{11}\delta_iI_{i,t}+E_t, ~~ donde ~~ E_t = \sum_{j=1}^{3} \phi_j E_{t-j}+ \Phi_1E_{t-12}- \Phi_1 \sum_{j=1}^{3}\phi_{t-j-12} + a_t + \sum_{i=1}^{6} \theta_i a_{t-i} + \Theta_1 a_{t-12} + \Theta_1 \sum_{i=1}^{6} \theta_i a_{t-i-12} , ~~con~  \{a_t\}_{t\in Z^+} \text{un RB} \sim N(0, \sigma_a^2) $$


* Paso 1) 


Ya esta listo!!!


* Paso 2)


```{r}
#indique valor correspondiente a p, q, P y Q en la función Arima, así como la matriz de predictores X en xreg=X
modelo4=Arima(yt,order=c(3,0,6),seasonal=list(order=c(1,0,1)),xreg=X,method="ML")
```



* Paso 3)

```{r}
#Calcule grados de libertad del MSE del modelo,
k4=length(coef(modelo4)[coef(modelo4)!=0])
k4 #número de parámetros del modelo
dfmodelo4=n-k4
#Construya tabla de parámetros estimados con estadísticos T0 y valores P para cada parámetro
coeftest(modelo4,df=dfmodelo4)
```

* Paso 4)


```{r}
ythat4=modelo4$fitted #este objeto ya queda con las fechas de la serie

#Gráfico de la serie y su ajuste
plot(datos)
lines(ythat4,col=2)
legend("topleft",legend=c("datos","ajuste modelo4"),lty=1,col=1:2)

#Gráficos de residuales
plot(residuals(modelo4))
abline(h=0)
abline(h=c(-2*sqrt(modelo4$sigma2),2*sqrt(modelo4$sigma2)),lty=2)

plot(as.numeric(modelo4$fitted),residuals(modelo4))
abline(h=0)
abline(h=c(-2*sqrt(modelo4$sigma2),2*sqrt(modelo4$sigma2)),lty=2)


```


* Paso 5) 

```{r}
AICmodelo4=exp(crit.inf.resid(residuales=residuals(modelo4),n.par=k4))
BICmodelo4=exp(crit.inf.resid(residuales= residuals(modelo4),n.par=k4,AIC="FALSE"))

AICmodelo4
BICmodelo4
```

* Paso 6)


```{r}
#ACF sobre residuales de ajuste en el modelo. Use valor para m el que se indica en la guía del trabajo
acf(as.numeric(residuals(modelo4)),ci.type="ma",lag.max=36,main="ACF modelo4",ci.col=2)

#PACF sobre residuales de ajuste en el modelo. Use valor para m el que se indica en la guía del trabajo
pacf(as.numeric(residuals(modelo4)),lag.max=36,main="PACF modelo4",ci.col=2)


BP.LB.test(residuals(modelo4),maxlag=36,type="Ljung") #test Ljung-Box use máximo m igual al de ACF y PACF

#Normalidad sobre residuales de ajuste en el modelo. Sólo si no se rechaza supuesto de ruido blanco
shapiro.test(residuals(modelo4))
qqnorm(residuals(modelo4),main="Gráfico de normalidad residuos de ajuste modelo4")
qqline(residuals(modelo4),col=2)
```


* Paso 7)


```{r}
#Cálculo del pronóstico con I.P del 95%, en escala original
predmodelo4=ts(as.data.frame(forecast(modelo4,xreg=Xnuevo,level=95)),freq=12, start=c(2001,1))
predmodelo4
ytpronmodelo4=predmodelo4[,1] #Tomando el pronóstico puntual. Este objeto tiene fechas
#Medidas precisión pronósticos
accuracy(ytpronmodelo4,ytf)
amplitud(LIP=predmodelo4[,2],LSP=predmodelo4[,3])
cobertura(real=ytf,LIP=predmodelo4[,2],LSP=predmodelo4[,3])

```









